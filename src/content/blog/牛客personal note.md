---
author: Hello
categories: matlab
title: 牛客personal note
description: '个人记录'
---

### 小基础

floor(x) 小于等于x的最大值整数（向下取整）   ceil(x) 大于等于x的最小整数（向上取整）( \#include<math.h> )

int 32位二进制  第一个是符号位正数为0，负数为1，后面是数值位 -2^31——2^31-1 

long long 64位二进制

double 64位二进制  （float别用了，太垃圾了）

~ 取反

`>>`右移   `<<`左移

pow(a,b) a的b次方



## 一维前缀和

拥有数组x和数组y，满足：

y0=x0;

y1=x0+x1;

y2=x0+x1+x2;

即想要求某区间和，可用y数组来相减得到结果



## 枚举

一一举例，不重复

先列举出（求第x数到第y数的和，先求数组所有和，直接减），（求四个点的位置，并且四个点组成正方形，先求四个点中的两个点，），（求一排树数量，部份树被整段移走（可能重叠），直接标记1，移走的树部分-1）

### 取尺法

分L，R两个指针，求数组区域<=s的连续数组的个数，<s  R右移，              >=s    L右移

使用前提：

1.能够维护一个区间，保证这个区间能够获得答案。

2.维护的具体操作可以左边移动一位、右边移动一位。

3.区间的变化是连续的而不是跳跃的。问题1就是比较跳跃的，双指针比较好，问题2不能跳跃。



## 贪心算法

局部最优解，然后发现局部最优=整体最优解



## 桶排序

列出数组， 将数组分到有限数量的桶里，将数据对比，有则让数组对应的数据+1，每个桶再个别排序 ，然后依次输出

 桶越多，时间效率就越高，而桶越多，空间就越大 

这里有位大佬我觉得写得很好，外加动漫配图，可以看一下（简单桶排序）

 https://www.cnblogs.com/bqwzx/p/11029264.html 

#### 计数排序

基数排序和计数排序都可以看做桶排序，计数排序的思路是开一个长度为 maxValue-minValue+1 的数组，进行分配+收集:

 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 

 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序 ， **计数排序非常浪费空间** 



## VECTOR

**vector是一个不限制数组长度的数组**

top()返回第一个元素    back()返回最后一个元素

erase（int index,int size）删除

vector<int> a;



## 迭代器Iterator

用于访问问一个容器内的数据的指针

vector<int>:: iterator it;



## C++ STL的二分查找

binary search 返回bool，是否存在

low_bound 返回可插入的最小位置的迭代器，即返回第一个符合条件的元素位置，low_bound(a,a+11,55), a[0]到a[10]找55，返回迭代器，可将结果  -a  得到它的下标   第一个<=x的位置

upper_bound 返回可插入的最大位置的迭代器，即返回最后一个符合条件的元素位置      第一个>x的位置