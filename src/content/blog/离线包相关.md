---
author: Hello
categories: 网络
title: '离线包相关'
description: '离线包相关'
pubDate: 2026-08-23 
---


## 1.离线包策略

分包：主包、子包，公共包

加载策略：

- 初始加载(APP 启动后马上下载)
- 配置变更时加载
- 场景加载
- 闲时加载
- 延迟加载
- 阻塞加载
- 智能加载





## diff

### bsdiff 算法

**优点**

- **压缩率极高** - 对于相似文件，补丁可能只有几KB
- **适合二进制文件** - 处理可执行文件、库文件效果好
- **算法成熟** - 被广泛应用于软件更新
- **跨平台** - 支持各种操作系统

**缺点**

- **内存消耗大** - 需要大量内存处理大文件
- **计算时间长** - 对于大文件生成补丁较慢
- **不适合完全不同的文件** - 如果文件差异太大，效果不佳



### 消息队列选型

#### BullMQ + Redis 消息队列详解

BullMQ 是什么

**BullMQ** 是一个基于 Redis 的 **Node.js 消息队列库**，用于处理异步任务和作业调度。

###### **核心功能**

- **任务队列管理**
- **作业调度**（延迟、重复、优先级）
- **并发控制**
- **失败重试**
- **进度跟踪**



```javascript
import { Queue, Worker } from 'bullmq';

// 创建队列
const emailQueue = new Queue('email');

// 添加任务
await emailQueue.add('send-email', {
  to: 'user@example.com',
  subject: 'Welcome!'
});

// 处理任务
const worker = new Worker('email', async (job) => {
  const { to, subject } = job.data;
  // 发送邮件逻辑
  await sendEmail(to, subject);
});
```



###### Redis 是什么

**Redis** 是一个高性能的**内存数据库**，支持多种数据结构。

**特点**

- **内存存储** - 极快的读写速度
- **持久化** - 数据可保存到磁盘
- **丰富数据类型** - 字符串、列表、集合、哈希等
- **原子操作** - 保证数据一致性

**使用方法**

```bash
# 安装启动
brew install redis
redis-server

# 基本操作
redis-cli
> SET key "value"
> GET key
> LPUSH queue "task1"
> RPOP queue
```



###### 消息队列原理

**基本概念**

- **生产者** - 发送消息到队列
- **队列** - 存储消息的缓冲区
- **消费者** - 从队列接收并处理消息

**工作流程**

```
生产者 → [消息队列] → 消费者
   ↓         ↓         ↓
 发送任务   暂存任务   处理任务
```

比如

**餐厅点餐系统**

想象一个繁忙的餐厅：

```
顾客点餐 → 服务员记录 → 厨房制作 → 上菜
  ↓           ↓           ↓        ↓
生产者    → 消息队列  →  消费者  → 结果
```

- **顾客**（生产者）：不断点餐
- **点餐单**（消息队列）：暂存订单
- **厨师**（消费者）：按顺序做菜
- **服务员**（Worker）：可以有多个同时工作





解决的问题

**异步处理**

```javascript
// 同步处理（阻塞）
app.post('/register', async (req, res) => {
  await createUser(req.body);
  await sendWelcomeEmail(req.body.email);  // 慢操作
  res.json({ success: true });
});

// 异步处理（非阻塞）
app.post('/register', async (req, res) => {
  await createUser(req.body);
  await emailQueue.add('welcome', req.body.email);  // 快速入队
  res.json({ success: true });
});
```

**提高可靠性**

- **任务重试**：失败自动重试
- **任务持久化**：服务重启不丢失
- **死信队列**：处理彻底失败的任务



###### **核心应用场景**

**1. 解耦系统**

- 服务间不直接调用
- 降低系统复杂度

**2. 削峰填谷**

- 处理突发流量
- 平滑系统负载

**3. 可靠性保证**

- 任务失败重试
- 消息持久化

**4. 扩展性**

- 水平扩展消费者
- 提高处理能力



**典型使用场景**

- **邮件发送**
- **图片处理**
- **数据同步**
- **定时任务**
- **支付处理**

BullMQ + Redis 组合提供了企业级的消息队列解决方案，特别适合需要高可靠性和高性能的 Node.js 应用。





### 队列其他需求处理

- 任务执行超时重试，超过最大重试次数报警通知上游
- 如果 worker 异常退出，自动重启 worker
- 任务堆积过多：告警
- 限制 worker 累计处理的最大任务数，超过自动杀死并重启新的（防止内存泄漏）